{
    "collab_server" : "",
    "contents" : "#\n# This is the server logic of a Shiny web application. You can run the \n# application by clicking 'Run App' above.\n#\n# Find out more about building applications with Shiny here:\n# \n#    http://shiny.rstudio.com/\n#\n\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(shinythemes)\nlibrary(shinydashboard)\nlibrary(shinyBS)\n\nlibrary(Rcampdf) # PDF tools\nlibrary(xlsx) # Write to excel\nlibrary(readxl) # Read from excel\nlibrary(tm) # Text Mining\nlibrary(pdftools) # Text Extraction\nlibrary(SnowballC) # Stemming\nlibrary(wordcloud) # Word Cloud\nlibrary(stringr) # Count substring in string\nlibrary(textcat) # Detect language of text\nlibrary(rhandsontable) # Interactive tables\nlibrary(plotly) # Interactive plots\n\nshinyServer(function(input, output) {\n  \n  output$table.pdfs <- renderTable(width = \"100%\", hover = TRUE, {\n    table <- data.frame(matrix(ncol = 1, nrow = 0))\n    colnames(table) <- \"No document(s) uploaded yet\"\n    \n    if (is.null(input$pdfs)){\n      return(table)\n    }\n    else{\n      enable(\"wordCloudButtonPDF\")\n      removeClass(\"pdf1\", \"missing\")\n      removeClass(\"pdf2\", \"missing\")\n      removeClass(\"pdf3\", \"missing\")\n      removeClass(\"pdf4\", \"missing\")\n      removeClass(\"pdf5\", \"missing\")\n      if(!is.null(input$longlists)){\n        enable(\"tdmButton\")\n        enable(\"tdmDownload\")\n        enable(\"plotButton\")\n        removeClass(\"not-allowed\", \"not-allowed\")\n        enable(\"wordCloudButtonLonglist\")\n      }\n      if(length(input$pdfs$name) == 1){\n        colnames(table) <- \"Uploaded document\"\n      }\n      else{\n        colnames(table) <- \"Uploaded documents\"\n      }\n      for(pdf in 1:length(input$pdfs$name)){\n        table[pdf,1] <- input$pdfs$name[pdf]\n      }\n      return(table)\n    }\n  })\n  \n  output$table.longlists <- renderTable(width = \"100%\", hover = TRUE, {\n    table <- data.frame(matrix(ncol = 1, nrow = 0))\n    colnames(table) <- \"No Longlist file(s) uploaded yet\"\n    \n    if (is.null(input$longlists)){\n      return(table)\n    }\n    else{\n      file.rename(input$longlists$datapath, paste(input$longlists$datapath, \".xlsx\", sep=\"\"))\n      removeClass(\"excel1\", \"missing\")\n      removeClass(\"excel2\", \"missing\")\n      removeClass(\"excel3\", \"missing\")\n      removeClass(\"excel4\", \"missing\")\n      if(length(input$longlists$name) == 1){\n        colnames(table) <- \"Uploaded longlist file\"\n      }\n      else{\n        colnames(table) <- \"Uploaded longlist files\"\n      }\n      for(longlist in 1:length(input$longlists$name)){\n        table[longlist,1] <- input$longlists$name[longlist]\n      }\n      return(table)\n    }\n  })\n  \n  output$tdmDownload <- downloadHandler(\n    filename = function() {\n      score <- \"\"\n      if(input$scoring == 1){\n        score <- \"[Count]\"\n      }\n      else if(input$scoring == 2){\n        score <- \"[Frequency]\"\n      }\n      else if(input$scoring == 3){\n        score <- paste(\"[Relative - \", input$threshold, \"]\", sep=\"\")\n      }\n      else {\n        score <- \"[Weighted]\"\n      }\n      prefix <- \"\"\n      if(input$title != \"\"){\n        prefix <- paste(input$title,\" - \", sep=\"\")\n      }\n      exportName <- paste(prefix,\"Matrix \", score ,\".xlsx\",sep=\"\")\n      paste(exportName, sep='')\n    },\n    content = function(path) {\n      saveTDM(getTDM(), path, readLonglists())\n    }\n  )\n  \n  output$logDownload <- downloadHandler(\n    filename = function() {\n      prefix <- \"\"\n      if(input$title != \"\"){\n        prefix <- paste(input$title,\" - \", sep=\"\")\n      }\n      exportName <- paste(prefix,\"Log\",\".txt\",sep=\"\")\n      paste(exportName, sep='')\n    },\n    content = function(path) {\n      file.copy(\"outfile.txt\", path)\n    }\n  )\n  \n  observeEvent(input$wordCloudButtonPDF, {\n    shinyjs::hide(\"iconWordCloudPDFEmpty\")\n    shinyjs::show(\"iconWordCloudPDFLoad\")\n    output$wordCloudPlotPDF <- renderPlot({\n      printWordCloudPDF()\n      shinyjs::hide(\"placeholderWordCloudPDF\")\n    })\n    shinyjs::show(\"wordCloudPlotPDF\")\n  })\n  \n  observeEvent(input$wordCloudButtonLonglist, {\n    shinyjs::hide(\"iconWordCloudLonglistEmpty\")\n    shinyjs::show(\"iconWordCloudLonglistLoad\")\n    output$wordCloudPlotLonglist <- renderPlot({\n      printWordCloudLonglist()\n      shinyjs::hide(\"placeholderWordCloudLonglist\")\n    })\n    shinyjs::show(\"wordCloudPlotLonglist\")\n    shinyjs::show(\"logDownload\")\n  })\n  \n  observeEvent(input$tdmButton, {\n    shinyjs::hide(\"iconTDMEmpty\")\n    shinyjs::show(\"iconTDMLoad\")\n    output$tdm <- renderDataTable({\n      getTDM()\n    }, options = list(pageLength = 10, scrollX = TRUE), \n    list(shinyjs::hide(\"placeholderTDM\")\n    ))\n    shinyjs::show(\"tdm\")\n    shinyjs::show(\"logDownload\")\n  })\n  \n  observeEvent(input$plotButton, {\n    shinyjs::show(\"plot\")\n    shinyjs::hide(\"iconPlotEmpty\")\n    shinyjs::show(\"iconPlotLoad\")\n    shinyjs::show(\"scoreBox\")\n    output$table.plot <- renderRHandsontable({\n      rhandsontable(getPlotTDM(), rowHeaders = TRUE) %>%\n        hot_validate_numeric(col = 2, min = 0, max = 10, allowInvalid = TRUE) %>%\n        hot_validate_numeric(col = 3, min = 0, max = 10, allowInvalid = TRUE) %>%\n        hot_col(col = 1, readOnly = TRUE, colWidths = 600) %>%\n        hot_col(col = 2, halign = \"htCenter\", format = \"0.0\") %>%\n        hot_col(col = 3, halign = \"htCenter\", format = \"0.0\") %>%\n        hot_col(col = 4, halign = \"htCenter\") %>%\n        hot_cols(columnSorting = TRUE)\n    })\n    shinyjs::show(\"logDownload\")\n  })\n  \n  observeEvent(input$table.plot, {\n    shinyjs::show(\"plot\")\n    shinyjs::hide(\"placeholderPlot\")\n    output$plot <- renderPlotly({\n      generatePlot(input$table.plot, 20)\n    })\n  })\n  \n  readDocuments <- reactive({\n    documentsLoad(input$pdfs)\n  })\n  \n  readLonglists <- reactive({\n    longlistLoad(input$longlists)\n  })\n  \n  wordCloudPDF <- reactive({\n    prepareWordCloudPDF(readDocuments())\n  })\n  \n  wordCloudLonglist <- reactive({\n    prepareWordCloudLonglist(getTDM())\n  })\n  \n  printWordCloudPDF <- reactive({\n    generateWordCloud(wordCloudPDF(), input$wordCloudPDFNumber)\n  })\n  \n  printWordCloudLonglist <- reactive({\n    generateWordCloud(wordCloudLonglist(), input$wordCloudLonglistNumber)\n  })\n  \n  getTDM <- reactive({\n    createTDM(readDocuments(), readLonglists(), input$scoring, input$threshold)\n  })\n  \n  getPlotTDM <- reactive({\n    preparePlotTDM(getTDM())\n  })\n  \n  printPlot <- reactive({\n    generatePlot(input$table.plot, 20)\n  })\n  \n  \n  \n  # \n  # >> prepareWordCloudPDF <<\n  # Input: text from pdf(s)\n  # Output: word frequency list\n  # \n  \n  prepareWordCloudPDF <- function(pdfs.text){\n    \n    withProgress(message = 'Generating Word Cloud', value = 0, {\n      \n      # Create corpus\n      corpus <- Corpus(VectorSource(pdfs.text))\n      incProgress(1/2)\n      \n      # Create TermDocumentMatrix\n      tdm <- TermDocumentMatrix(corpus, control = list(removePunctuation = TRUE,\n                                                       stopwords = TRUE,\n                                                       tolower = TRUE,\n                                                       stemming = FALSE,\n                                                       removeNumbers = TRUE,\n                                                       bounds = list(global = c(1, Inf))))\n      \n      incProgress(1/2)\n      \n      # Create the table with the correct names\n      result <- as.matrix(tdm)\n      result <- rowSums(result)\n    })\n    return(result)\n  }\n  \n  \n  \n  # \n  # >> prepareWordCloudLonglist <<\n  # Input: term document matrix\n  # Output: term frequency list\n  # \n  \n  prepareWordCloudLonglist <- function(tdm){\n    frequency <- c(tdm[,2])\n    synonym = list()\n    \n    for(i in 1:nrow(tdm)){\n      split <- strsplit(toString(tdm[i,1]), \" / \")\n      split <- split[[1]][1]\n      synonym <- c(synonym, split)\n    }\n    \n    names(frequency) <- synonym\n\n    return(frequency)\n  }\n  \n  \n  \n  # \n  # >> generateWordCloud <<\n  # Input: term / word frequency list and number of term / words to display\n  # Output: word cloud\n  #\n  \n  generateWordCloud <- function(frequency, number){\n    \n    # Check if the number of terms to show in the word cloud is not bigger than the number of words to show\n    if(number > length(frequency)){\n      number <- length(frequency)\n    }\n    \n    # Sort the frequencies\n    frequency <- sort(frequency, decreasing = TRUE)\n    \n    words <- names(frequency)\n    return(wordcloud(words[1:number], frequency[1:number], min.freq = 1, random.order=FALSE, rot.per=0.35, use.r.layout = FALSE, colors=brewer.pal(4, \"Paired\")))\n  }\n  \n  \n  \n  # \n  # >> createTDM <<\n  # Input: text from pdf(s), longlist terms, scoring scheme and threshold\n  # Output: term document matrix\n  # \n  \n  createTDM <- function(allpdfs.text, longlist, scheme, threshold){\n    withProgress(message = 'Generating Table', value = 0, {\n      \n      columns <- NULL\n      \n      # Iterate over all categories\n      for (cat in 1:length(names(allpdfs.text))) {\n        \n        catName <- names(allpdfs.text)[cat]\n        \n        # If it is a category with PDFs underneath it add [Category] to the name\n        if(!grepl('.pdf', catName, fixed=TRUE)){\n          catName <- paste(\"[Category]\", catName, sep=\" \")\n        }\n        \n        # Remove '.pdf', dashes and hyphens from pdf name\n        catName <- gsub(\".pdf\", \"\", catName)\n        catName <- gsub(\"_\",\" \", catName)\n        catName <- gsub(\"-\",\" \", catName)\n        columns[cat] <- catName\n      }\n      \n      # Create empty TermDocumentMatrix\n      tdm <- data.frame(matrix(ncol = length(columns)+1, nrow = 0), stringsAsFactors=FALSE)\n      colnames(tdm) <- c(\"Longlist\", columns)\n      \n      \n      # Store the longlist topics in the first column\n      for(row in 1:nrow(longlist)){\n        terms <- toString(longlist[row,2])\n        tdm[row,1] <- terms\n      }\n      \n      # Create an empty log file\n      sink(\"outfile.txt\")\n      \n      # Iterate over every category \n      for(l in 1:length(columns)){\n        \n        pdfs.text <- allpdfs.text[[l]]\n        categoryName <- columns[l]\n        incProgress(1/length(columns), detail = paste(\"Scanning: \", categoryName))\n        \n        # Create category table\n        pdfNames <- names(pdfs.text)\n        catTDM <- data.frame(matrix(ncol = length(pdfNames)+1, nrow = 0), stringsAsFactors=FALSE)\n        colnames(catTDM) <- c(\"Longlist\", pdfNames)\n        \n        # Iterate over every pdf in the category\n        for(pdf in 1:length(pdfs.text)){\n          pdfName <- pdfNames[pdf]\n          pdfPages <- pdfs.text[[pdf]]\n          \n          # Determine langauge for the pdf by scanning the first 10 words of each page.\n          languages <- textcat(pdfPages[1:10])\n          language <- names(which.max(table(languages)))\n          language.column <- grep(language, colnames(longlist), ignore.case=TRUE)\n          \n          # If the detected language is not found in the longlist it will use the first row\n          if(length(language.column) == 0){\n            language.column <- 2\n          }\n          \n          # Iterate over every row in the longlist\n          for(row in 1:nrow(longlist)){\n            \n            # Extract the row\n            terms <- toString(longlist[row,language.column])\n            terms.frequency <- 0\n            \n            # Check if row is not empty\n            if(terms != \"NA\"){\n              # Extract the synonyms per row\n              terms.list <- strsplit(tolower(terms), \" / \")\n              \n              # Iterate over the synonyms\n              for(synonym in 1:length(terms.list[[1]])){\n                \n                # Get the frequency of the synonym\n                term <- terms.list[[1]][synonym]\n                term.frequency <- getFrequency(term, pdfPages, categoryName, pdfName, language)\n                terms.frequency <- terms.frequency + term.frequency\n              }\n            }\n            \n            # If the scoring scheme is 'relative', we use the frequency divided by pages\n            if(scheme == 3){\n              npages <- length(pdfPages)\n              score <- terms.frequency / npages\n              score <- round(score,digits=3)\n              catTDM[row,pdf+1] <- score\n            }\n            \n            # If the scoring scheme is not 'relative', we can use the frequency\n            else{\n              \n              # Save frequency of synonyms to dataframe\n              catTDM[row,pdf+1] <- terms.frequency\n            }\n          }\n        }\n        \n        # After a category table is created (containing all the pdfs of that category), add the score column to it\n        catTDM <- addScore(catTDM, scheme, threshold, TRUE)\n        \n        # Add the score column of the category table to the main table\n        tdm[1:nrow(tdm),l+1] <- catTDM[1:nrow(catTDM),2]\n      }\n      \n      # After all the categories columns are added, add the score column to the main tdm\n      tdm <- addScore(tdm, scheme, threshold, FALSE)\n      \n      # Set the correct names again\n      colnames(tdm) <- c(\"Longlist\", \"Score\", columns)\n      \n    })\n    return(tdm)\n  }\n  \n  \n  \n  # \n  # >> addScore <<\n  # Input: term document matrix, scoring scheme, threshold and a boolean whether it is a category tdm or the main tdm\n  # Output: term document matrix with a score column\n  # \n  \n  addScore <- function(tdm, scheme, threshold, category){\n    \n    # If the scoring scheme is 'count'\n    if(scheme == 1){\n      \n      # If the tdm has only one category/pdf\n      if(ncol(tdm) == 2){\n        \n        # Add a score column with a total of all the columns\n        tdm <- as.data.frame(append(tdm, list(Score = tdm[,2]), after = 1))\n        \n        # Iterate over each topic in the longlist\n        for(i in 1:nrow(tdm)){\n          \n          # If the topic occurs in at least ones, change it to 1 (so 0 stays 0)\n          if(tdm[i,2] > 0){\n            tdm[i,2] <- 1\n          }\n        }\n      }\n      \n      # If the tdm has more than one category/pdf\n      else{\n        \n        # Add a score column with 1 if at least one other column is bigger than 0\n        tdm <- as.data.frame(append(tdm, list(Score = rowSums(tdm[,2:ncol(tdm)] > 0)), after = 1))\n      }\n    }\n    \n    # If the scoring scheme is 'frequency' or if the scoring scheme is 'weighted' & it is a category table.\n    # We do not want to lower the frequency twice (we do this only for the main table)\n    else if(scheme == 2 || (scheme == 4 && category)){\n      \n      # If the tdm has only one category/pdf\n      if(ncol(tdm) == 2){\n        \n        # Add a score column that is equal to the one column\n        tdm <- as.data.frame(append(tdm, list(Score = tdm[,2]), after = 1))\n      }\n      \n      # If the tdm has more than one category/pdf\n      else{\n        \n        # Add a score column with a total of all the columns\n        tdm <- as.data.frame(append(tdm, list(Score = rowSums(tdm[,2:ncol(tdm)])), after = 1))\n      }\n    }\n    \n    # If the scoring scheme is 'relative'\n    else if (scheme == 3){\n      \n      # Add a score column with a total of all the columns\n      tdm <- as.data.frame(append(tdm, list(Score = tdm[,2]), after = 1))\n      \n      # Iterate over each row in the matrix\n      for(row in 1:nrow(tdm)){\n        score <- 0\n        \n        # Iterate over each pdf in the matrix\n        for(pdf in 3:ncol(tdm)){\n          \n          value <- tdm[row,pdf]\n          \n          # If it is a category table\n          if(category){\n            \n            # Count 1 if value is bigger or equal to the threshold\n            if(value >= threshold){\n              score <- score + 1\n            }\n          }\n          \n          # If it is the main table\n          else {\n            \n            # Count 1 if value is bigger than 0\n            # Because for each category we already did the bigger or equal to the threshold check\n            if(value > 0){\n              score <- score + 1\n            }\n          }\n        }\n        \n        # Save the score to the Score column\n        tdm[row,2] <- score\n      }\n    }\n    \n    # If the scoring scheme is 'weighted'\n    else{\n      \n      # If the tdm has only one category/pdf\n      if(ncol(tdm) == 2){\n        \n        # Add a score column that is equal to the one column\n        tdm <- as.data.frame(append(tdm, list(Score = tdm[,2]), after = 1))\n      }\n      \n      # If the tdm has more than one category/pdf\n      else{\n        \n        # Get the total frequency for each longlist topic\n        tdm.frequency <- list(rowSums(tdm[,2:ncol(tdm)]))\n        \n        # Get the number of categories/pdfs for each longlist topic for which the frequency is bigger than 0\n        tdm.count <- list(rowSums(tdm[,2:ncol(tdm)] > 0))\n        \n        # Divide the total frequency for each longlist topic by the total number of categories/pdfs\n        tdm.mixed <- mapply('/', tdm.frequency, (ncol(tdm) - 1))\n        \n        # Multiply the above by the number of categories/pdfs with a score higher than 0\n        tdm.mixed <- list(Score = unlist(tdm.mixed)*unlist(tdm.count))\n        \n        # Add the score column to the tdm\n        tdm <- as.data.frame(append(tdm, tdm.mixed, after = 1))\n      }\n    }\n    \n    return(tdm)\n  }\n  \n  \n  \n  # \n  # documentsLoad: unzipping files and loading the text from the pdf file(s)\n  # Input: folder path\n  # Output: list with all the text in the pdf(s) per category\n  # \n  \n  documentsLoad <- function(files){\n    withProgress(message = 'Reading documents', value = 0, {\n      \n      pdfs <- c()\n      categories <- c()\n      \n      # Iterate over all the uploaded files\n      number.files <- length(files[,1])\n      for(i in 1:number.files){\n        fileName <- files[[i, 'name']]\n        incProgress(0, detail = \"Scanning documents\")\n        \n        # If the file is a .zip, unzip it\n        if(grepl(\".zip\", fileName, fixed=TRUE)){\n          zipFiles <- unzip(files[[i, 'datapath']], list = TRUE)\n          \n          # Iterate over each file in the zip\n          for(n in 1:nrow(zipFiles)){\n            zipContent <- zipFiles[n,\"Name\"]\n            zipName <- gsub('.zip','',fileName)\n            mainFolder <- paste(zipName,\"/\",sep=\"\")\n            \n            # Only check the file in the zip if it is valid\n            if(str_count(zipContent, \"__MACOSX\") == 0 && str_count(zipContent, \".DS_Store\")== 0 && mainFolder != zipContent){\n              \n              # If the file is a pdf, read the pdf\n              if(grepl(\".pdf\", zipContent)){\n                if(str_count(zipContent, \"/\") == 1){\n                  categories[length(categories) + 1] <- zipContent\n                }\n                pdfs[length(pdfs) + 1] <- zipContent\n              }\n              # If the file within the zip is an invalid format, ignore it\n              else if (grepl(\".xls\", zipContent, fixed=TRUE) || grepl(\".xlsx\", zipContent, fixed=TRUE) || grepl(\".doc\", zipContent, fixed=TRUE) || grepl(\".docx\", zipContent, fixed=TRUE) || grepl(\".jpg\", zipContent, fixed=TRUE) || grepl(\".png\", zipContent, fixed=TRUE) || grepl(\".iso\", zipContent, fixed=TRUE) || grepl(\".txt\", zipContent, fixed=TRUE)) {\n                # Do nothing\n              }\n              # If the file is a folder, add as category\n              else{\n                zipContent <- gsub('/','',gsub(zipName,'',zipContent))\n                categories[length(categories) + 1] <- zipContent\n              }\n            }\n          }\n          unzip(files[[i, 'datapath']], exdir = \"unzip\", overwrite = TRUE)\n        }\n        # If the file is a .pdf add it as an own category and read the pdf\n        else if(grepl(\".pdf\", fileName)){\n          categories[length(categories) + 1] <- paste(fileName)\n          pdfs[length(pdfs) + 1] <- paste(fileName)\n        }\n        # Documents other than pdf or zip are ignored\n      }\n      \n      allpdfs.text = NULL\n      \n      # Iterate over each category\n      for(number in 1:length(categories)) {\n        category <- categories[number]\n        pdfs.text <- NULL\n        \n        incProgress(1/length(categories), detail = category)\n        \n        # If it is a pdf that is directly uploaded\n        if(str_count(category, \"/\") == 0  && str_count(category, \".pdf\") == 1) {\n          path <- files[[which(grepl(category, files$name, fixed=TRUE)),'datapath']]\n          pdfs.text[[category]] <- pdf_text(path)\n          \n          # Clean text\n          pdfs.text <- cleanText(pdfs.text)\n          \n          # Save pdf text as category\n          allpdfs.text[[category]] <- pdfs.text\n        }\n        # If it is a pdf that is uploaded in a zip\n        else if(str_count(category, \"/\") == 1 ) {\n          path <- paste(\"unzip/\",category,sep=\"\")\n          pos = regexpr('/', category)\n          category <- substr(category, pos+1, nchar(category))\n          pdfs.text[[category]] <- pdf_text(path)\n          \n          # Clean text\n          pdfs.text <- cleanText(pdfs.text)\n          \n          # Save pdf text as category\n          allpdfs.text[[category]] <- pdfs.text\n        }\n        # If it is a category with pdfs underneath it\n        else{\n          positions <- which(grepl(paste(\"/\",category,\"/\",sep=\"\"), pdfs, fixed=TRUE))\n          \n          # Iterate over each pdf file of this category\n          for(k in 1:length(positions)){\n            category.pdf <- pdfs[positions[k]]\n            path <- paste(\"unzip/\",category.pdf,sep=\"\")\n            pos <- gregexpr('/', category.pdf)\n            pos <- pos[[1]][length(pos[[1]])]\n            category.pdf <- substr(category.pdf, pos+1, nchar(category.pdf))\n            pdfs.text[[category.pdf]] <- pdf_text(path)\n          }\n          \n          # Clean text\n          pdfs.text <- cleanText(pdfs.text)\n          \n          # Save text of all pdfs to category\n          allpdfs.text[[category]] <- pdfs.text\n        }\n      }\n    })\n    return(allpdfs.text)\n  }\n  \n  \n  # \n  # longlistLoad: loading the longlist from the excel sheet(s)\n  # Input: folder path\n  # Output: merged longlist with a languages per column\n  # \n  \n  longlistLoad <- function(files){\n    withProgress(message = 'Reading longlist files', value = 0, {\n      \n      number.files <- length(files[,1])\n      \n      # Merge longlist files to one list\n      longlist.data <- NULL\n      for(i in 1:number.files){\n        incProgress(1/number.files, detail = paste(files[[i, 'name']]))\n        file <- paste(files[[i, 'datapath']], sep = \".\", \"xlsx\")\n        longlist <- rbind(longlist.data, read_excel(file))\n      }\n    })\n    return(longlist)\n  }\n  \n  \n  \n  #\n  # >> cleanText <<\n  # Input: pdf text\n  # Output: cleaned pdf text\n  #\n  \n  cleanText <- function(pdfs.text){\n    \n    # Replace line breaks, page breaks and tabs with a space\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"[\\r\\n\\t]\",\" \",x))\n    \n    # Replace slashes\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"\\u2215|\\u2044\",\" \",x))\n    \n    # Replace parentheses with a space\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"\\\\(\",\" \",x))\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"\\\\)\",\" \",x))\n    \n    # Remove all full stops\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\".\",\"\",x,fixed = TRUE))\n    \n    # Remove all question marks, quotation marks, asterisks, bullet points and weird symbols\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"?\",\"\",x,fixed = TRUE))\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"\\\"\",\"\",x,fixed = TRUE))\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"*\",\"\",x,fixed = TRUE))\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"●\",\"\",x,fixed = TRUE))\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"\",\"\",x,fixed = TRUE))\n    \n    # Remove all sorts of commas, full stops, colons, semicolons, question marks, exclamation points, quotation marks, euro signs, dollar signs, pound signs\n    pdfs.text <- lapply(pdfs.text, function(x)gsub(\"\\u002C|\\uFF0C|\\u0326|\\u02BB|\\u003A|\\uFF1A|\\u003B|\\uFF1B|\\u204F|\\uFE54|\\u003F|\\uFF1F|\\u0021|\\uFF01|\\u201C|\\u2018|\\u2019|\\u201D|\\u20AC|\\u0024|\\uFF04|\\u00A3|\\uFFE1\",\"\",x))\n    \n    # Change all text to lower case\n    pdfs.text <- lapply(pdfs.text, tolower)\n    \n    return(pdfs.text)\n  }\n  \n  \n  \n  #\n  # >> getFrequency <<\n  # Input: term, pdf text, category name, pdf name, language\n  # Output: the number of times the term occures in the pdf \n  #\n  \n  getFrequency <- function(term, pdf, categoryName, pdfName, language){\n    frequency <- 0\n    \n    # Add a space before and after the term to avoid counting terms that are part of a bigger term\n    term <- paste(\" \", term, \" \", sep=\"\")\n    \n    # Iterate over the paragraphs\n    for(page in 1:length(pdf)){\n      frequency.page <- str_count(pdf[page], term)\n      frequency <- frequency + frequency.page\n      if(frequency.page > 0){\n        \n        # In case a term is found on a pdf page, print the pdf name, the language, the term, the page number and the number of occurences to the log file\n        # If pdf is in a category, also print the category name to the log\n        if (grepl(\"[Category]\", categoryName, fixed=TRUE)){\n          categoryName <- gsub('[Category] ','[Category]', categoryName, fixed = TRUE)\n          log <- paste(categoryName, \" [PDF]\", pdfName, \"  [LANGUAGE]\", language, \"  [TERM]\", term, \"  [PAGE]\", page, \"  [OCCURRENCES]\", frequency.page, \"\\n\", sep = \"\")\n        }\n        else{\n          log <- paste(\"[PDF]\", pdfName, \"  [LANGUAGE]\", language, \"  [TERM]\", term, \"  [PAGE]\", page, \"  [OCCURRENCES]\", frequency.page, \"\\n\", sep = \"\")\n        }\n        \n        # Log every match that is found in the PDFs \n        cat(log)\n      }\n    }\n    \n    return(frequency)\n  }\n  \n  \n  \n  #\n  # >> saveTDM <<\n  # Input: tdm, path and longlist (for topic category names)\n  # Output: save excel file to path\n  #\n  \n  saveTDM <- function(tdm, path, longlist){\n    withProgress(message = 'Saving Matrix', value = 0, {\n      \n      # Create empty excel file\n      excel <- createWorkbook(type=\"xlsx\")\n      sheet <- createSheet(excel, sheetName=\"Longlist Results\")\n      \n      \n      # Define Layout\n      # Define borders\n      border.title <- Border(color = \"black\", pen = c(\"BORDER_MEDIUM\", \"BORDER_MEDIUM\", \"BORDER_THIN\", \"BORDER_THIN\"), position = c(\"TOP\", \"BOTTOM\", \"LEFT\", \"RIGHT\"))\n      border.normal <- Border(color = \"black\", pen = c(\"BORDER_THIN\", \"BORDER_THIN\", \"BORDER_MEDIUM\", \"BORDER_MEDIUM\"), position = c(\"TOP\", \"BOTTOM\", \"LEFT\", \"RIGHT\"))\n      border.score <- Border(color = \"black\", pen = \"BORDER_MEDIUM\", position = c(\"TOP\", \"BOTTOM\", \"LEFT\", \"RIGHT\"))\n      \n      # Define allignments\n      aligntment.columns <- Alignment(wrapText = TRUE, rotation = 60)\n      alignment.list <- Alignment(wrapText = TRUE)\n      alignment.standard <- Alignment(horizontal = \"ALIGN_CENTER\", vertical = \"VERTICAL_CENTER\", wrapText = TRUE)\n      alignment.categorie <- Alignment(horizontal = \"ALIGN_CENTER\", wrapText = TRUE)\n      \n      # Define fills\n      fill.gray <- Fill(foregroundColor = \"#BFBFBF\")\n      fill.lightgray <- Fill(foregroundColor = \"#D9D9D9\")\n      fill.white <- Fill(foregroundColor = \"white\")\n      fill.lightgreen <- Fill(foregroundColor = \"#ECF0E0\")\n      fill.lightblue <- Fill(foregroundColor = \"#DFE9EF\")\n      fill.red <- Fill(foregroundColor = \"#E7726F\")\n      fill.green1 <- Fill(foregroundColor = \"#FCEC92\")\n      fill.green2 <- Fill(foregroundColor = \"#CFDC8D\")\n      fill.green3 <- Fill(foregroundColor = \"#B9D48A\")\n      fill.green4 <- Fill(foregroundColor = \"#7ABC81\")\n      \n      # Define fonts\n      font.big <- Font(excel, heightInPoints = \"16\", name = \"Calibri\")\n      font.normal <- Font(excel, heightInPoints = \"10\", name = \"Calibri\")\n      \n      style.title.score <- CellStyle(excel, alignment = aligntment.columns, border = border.score, fill = fill.lightgray, font = font.big)\n      style.title.first <- CellStyle(excel, border = border.score, fill = fill.white, font = font.normal)\n      style.title <- CellStyle(excel, alignment = aligntment.columns, border = border.title, fill = fill.lightgreen, font = font.normal)\n      style.title.bundle <- CellStyle(excel, alignment = aligntment.columns, border = border.title, fill = fill.lightblue, font = font.normal)\n      style.title.categorie <- CellStyle(excel, alignment = alignment.categorie, border = border.score, fill = fill.gray, font = font.normal)\n      \n      style.list.score <- CellStyle(excel, alignment = alignment.standard, border = border.normal, font = font.normal)\n      style.list.score.green1 <- CellStyle(excel, alignment = alignment.standard, border = border.normal, font = font.normal, fill = fill.green1)\n      style.list.score.green2 <- CellStyle(excel, alignment = alignment.standard, border = border.normal, font = font.normal, fill = fill.green2)\n      style.list.score.green3 <- CellStyle(excel, alignment = alignment.standard, border = border.normal, font = font.normal, fill = fill.green3)\n      style.list.score.green4 <- CellStyle(excel, alignment = alignment.standard, border = border.normal, font = font.normal, fill = fill.green4)\n      style.list.score.red <- CellStyle(excel, alignment = alignment.standard, border = border.normal, font = font.normal, fill = fill.red)\n      style.list.first <- CellStyle(excel, alignment = alignment.list, border = border.normal, font = font.normal)\n      style.list <- CellStyle(excel, alignment = alignment.standard, border = border.normal, font = font.normal)\n      style.list.categorie <- CellStyle(excel, alignment = alignment.standard, border = border.score, fill = fill.gray, font = font.normal)\n      \n      # Set column styles\n      colstyle <- list('1' = style.list.first, '2' = style.list.score)\n      for(i in 3:ncol(tdm)){\n        colstyle[[paste(i)]] <- style.list\n      }\n      \n      # Store TermDocumentMatrix to excel file\n      addDataFrame(tdm, sheet, col.names=TRUE, row.names=FALSE,\n                   startRow=1, startColumn=2, colStyle=colstyle, colnamesStyle=style.title)\n      \n      # Set row height\n      row <- getRows(sheet, rowIndex = 1)\n      setRowHeight(row, 90)\n      \n      # Set column width\n      setColumnWidth(sheet, colIndex = 2, colWidth = 50)\n      \n      # Set individual cells\n      row <- getRows(sheet, rowIndex = 1)\n      cells <- getCells(row)\n      setCellStyle(cells[[2]], style.title.score)\n      setCellStyle(cells[[1]], style.title.first)\n      for(i in 3:ncol(tdm)){\n        if (grepl(\"[Category]\", names(tdm)[i], fixed=TRUE)){\n          cells <- getCells(getRows(sheet, rowIndex = 1))\n          setCellStyle(cells[[i]], style.title.bundle)\n        }\n      }\n      \n      incProgress(1/2)\n      \n      # Set colors for score\n      for(i in 1:nrow(tdm)+1){\n        row <- getRows(sheet, rowIndex = i)\n        cells <- getCells(row)\n        value <- getCellValue(cells[[2]])\n        if(value > 0 & value < 5){\n          setCellStyle(cells[[2]], style.list.score.green1)\n        }\n        else if(value > 4 & value < 10){\n          setCellStyle(cells[[2]], style.list.score.green2)\n        }\n        else if(value > 9 & value < 20){\n          setCellStyle(cells[[2]], style.list.score.green3)\n        }\n        else if(value > 19){\n          setCellStyle(cells[[2]], style.list.score.green4)\n        }\n        else{\n          setCellStyle(cells[[2]], style.list.score.red)\n        }\n      }\n      \n      # Freeze cells\n      createFreezePane(sheet, rowSplit = 2, colSplit = 4, startRow=NULL, startColumn=NULL)\n      \n      # Set zoom\n      setZoom(sheet, numerator = 130, denominator = 100)\n      \n      # Set print area\n      setPrintArea(excel, sheetIndex = 1, startColumn = 1, endColumn = ncol(tdm), startRow = 1, endRow = nrow(tdm))\n      \n      # Add categories\n      longlist <- as.matrix(longlist[1])\n      addDataFrame(longlist, sheet, col.names=TRUE, row.names=FALSE, startRow=1, startColumn=1, colStyle = list('1' = style.list.categorie), colnamesStyle=style.title.categorie)\n      \n      # Add the topic category names to the first column. Merge the category cells for topics that are part of the same category \n      lastWord = \"\"\n      start = 0\n      \n      for(i in 1:nrow(longlist)){\n        word = longlist[i]\n        if(word != lastWord & !is.na(word)){\n          if(start != 0){\n            addMergedRegion(sheet, start+1, i, 1, 1)\n          }\n          start = i\n          lastWord = word\n        }\n      }\n      addMergedRegion(sheet, start+1, nrow(longlist)+1, 1, 1)\n      \n    })\n    \n    #Save the file\n    saveWorkbook(excel, path)\n  }\n  \n  \n  \n  #\n  # >> generatePlot <<\n  # Input: term frequency list and number to display\n  # Output: plot\n  #\n  \n  generatePlot <- function(tdm, number){\n    # Translate the table in the user interface to a R data frame\n    tdm <- hot_to_r(tdm)\n    \n    # Add a column to the tdm\n    tdm$Synonym <- NULL\n    \n    # Iterate over each topic in the tdm and store the first synonym in the newly created column\n    for(row in 1:nrow(tdm)){\n      split <- strsplit(toString(tdm[row,1]), \" / \")\n      split <- split[[1]][1]\n      tdm[row,5] <- split\n    }\n    \n    # Create a scatter plot for the tdm\n    # Use only the first synonym of a topic to show in the plot, but show all synoynms of a topic when the users hovers over it\n    plot <- plot_ly(x = tdm[tdm[,4] == TRUE,3], y = tdm[tdm[,4] == TRUE,2], type = 'scatter', mode = 'markers', text = tdm[tdm[,4] == TRUE,5], hovertext = tdm[tdm[,4] == TRUE,1],\n                    hoverinfo = 'x+y+text', showlegend = FALSE, marker = list(size = 10,\n                                                                              color = 'rgba(184, 230, 255, .9)',\n                                                                              line = list(color = 'rgba(0, 77, 153, .8)',\n                                                                                          width = 2))) %>%\n      add_text(textfont = list(\n        family = \"sans serif\",\n        size = 14,\n        color = toRGB(\"grey50\")),\n        textposition = \"bottom center\") %>%\n      \n      layout(title = 'Materiality Matrix',\n             xaxis = list(\n               nticks = 10,\n               range = c(-1, 11),\n               title = \"Importance internal stakeholders\",\n               titlefont = list(\n                 family = 'Arial, sans-serif',\n                 size = 15,\n                 color = 'black'\n               ),\n               showexponent = 'All'\n             ),\n             yaxis = list(\n               nticks = 10,\n               range = c(-1, 11),\n               title = \"Importance external stakeholders\",\n               titlefont = list(\n                 family = 'Arial, sans-serif',\n                 size = 15,\n                 color = 'black'\n               ),\n               showexponent = 'All'\n             )\n      )\n    return(plot)\n  }\n  \n  \n  \n  #\n  # >> preparePlotTDM <<\n  # Input: term document matrix\n  # Output: matrix with topics, external score, internal scofre and show columns\n  #\n  \n  preparePlotTDM <- function(tdm){\n    \n    # Only take the topics and the score column\n    tdm <- tdm[,1:2]\n    \n    # The score column is for the external axis\n    colnames(tdm)[2] <- \"External\"\n    \n    # Add the internal axis column\n    tdm$Internal <- rep(0,nrow(tdm))\n    \n    # Order the tdm on the external axis score\n    tdm <- tdm[order(tdm$External, decreasing=TRUE), ]\n    \n    # Add a column to store whether to show a topic in the matrix or not -> default is FALSE\n    tdm$Show <- rep(FALSE,nrow(tdm))\n    \n    # Normalize the values to a range between 10 and 0. Highest score gets a 10\n    highestvalue <- tdm[1,2]\n    for(row in 1:nrow(tdm)){\n      score <- tdm[row,2]/highestvalue*10\n      tdm[row,2] <- score\n      \n      # Only set topics to show is TRUE when the external axis score is higher than 1\n      if(score > 1){\n        tdm[row,4] <- TRUE\n      }\n    }\n    \n    return(tdm)\n  }\n})",
    "created" : 1509972272494.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3840054549",
    "id" : "D4F322E5",
    "lastKnownWriteTime" : 1511437595,
    "last_content_update" : 1511437595927,
    "path" : "~/sustainalize/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}